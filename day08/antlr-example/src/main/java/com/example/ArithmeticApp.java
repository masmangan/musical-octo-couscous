package com.example;

import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.Trees;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.IOException;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.antlr.v4.runtime.tree.Trees;
import org.antlr.v4.runtime.tree.RuleNode;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * A simple application to demonstrate the use of ANTLR for parsing arithmetic
 * expressions.
 * The application takes an arithmetic expression as a string, parses it using a
 * lexer and parser
 * generated from the Arithmetic grammar, and outputs the resulting parse tree
 * in a LISP-like format.
 */
public class ArithmeticApp {

    /**
     * Private constructor to prevent instantiation of this utility class.
     */
    private ArithmeticApp() {
    }

    /**
     * Parses the input string as an arithmetic expression and returns the
     * corresponding parse tree.
     *
     * @param input The arithmetic expression to parse.
     * @return The parse tree as a string in a LISP-like format.
     */
    public static String getTreeFromString(String input) {
        // Step 1: Create an input stream from a string (or file)
        ArithmeticLexer lexer = new ArithmeticLexer(CharStreams.fromString(input));

        // Step 2: Create a token stream from the lexer
        CommonTokenStream tokens = new CommonTokenStream(lexer);

        // Step 3: Create a parser from the token stream
        ArithmeticParser parser = new ArithmeticParser(tokens);

        // Step 4: Parse the input using a rule (start rule typically)
        ParseTree tree = parser.expr(); // Replace 'expr' with your grammar's start rule

        String filename = "example.dot";
        saveParseTreeAsDot(tree, parser, filename);

        // Step 5: Get the parse tree
        return tree.toStringTree(parser);
    }

    /**
     * Saves the parse tree of a given input as a DOT file.
     *
     * This method generates a string representation of the parse tree in DOT
     * format,
     * which is a graph description language. The method then writes this
     * representation
     * to a file specified by the user. The resulting DOT file can be used with
     * tools like
     * Graphviz to visualize the parse tree as an image or diagram.
     *
     * @param tree     The parse tree generated by the parser.
     * @param parser   The parser that produced the parse tree.
     * @param filename The name of the file where the DOT representation should be
     *                 saved.
     */
    public static void saveParseTreeAsDot(ParseTree tree, ArithmeticParser parser, String filename) {
        try {
            // Convert the parse tree to a DOT representation
            StringBuilder dot = new StringBuilder();
            dot.append("digraph ParseTree {\n");
            dot.append("  node [shape=none, fontname=\"Courier\"];\n");
            dot.append("  rankdir=TB;\n");

            toDot(tree, parser, dot, 0);

            dot.append("}\n");

            // Write the DOT string to a file
            Files.write(Paths.get(filename), dot.toString().getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Recursive method to generate DOT representation of the parse tree.
     *
     * @param node   The current parse tree node.
     * @param parser The parser that produced the parse tree.
     * @param dot    The StringBuilder to accumulate the DOT representation.
     * @param id     The unique ID for the current node.
     * @return The next available unique ID for subsequent nodes.
     */
    private static int toDot(ParseTree node, ArithmeticParser parser, StringBuilder dot, int id) {
        int nodeId = id;

        String nodeName = node.getClass().getSimpleName().replaceAll("Context$", "");

        // Append the current node to the DOT representation
        dot.append("  node").append(nodeId).append(" [label=\"").append(nodeName).append("\"];\n");

        // Process children
        for (int i = 0; i < node.getChildCount(); i++) {
            int childId = ++id;
            dot.append("  node").append(nodeId).append(" -> node").append(childId).append(";\n");
            id = toDot(node.getChild(i), parser, dot, childId);
        }

        return id;
    }

    /**
     * The main method serves as the entry point for the application.
     * It demonstrates the parsing of a simple arithmetic expression.
     *
     * @param args Command-line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("Hello ANTLR!");

        // Example input expression
        String input = "2";

        // Output the parse tree for the input expression
        System.out.println(getTreeFromString(input)); // Prints the parse tree in LISP-like format
    }
}
